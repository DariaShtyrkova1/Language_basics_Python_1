import random


# Задание 1.

# Написать функцию num_translate(), переводящую числительные от 0 до 10 c английского на русский язык. Например:
# >>> num_translate("one")
# "один"
# >>> num_translate("eight")
# "восемь"

# Если перевод сделать невозможно, вернуть None.
# Подумайте, как и где лучше хранить информацию,
# необходимую для перевода: какой тип данных выбрать, в теле функции или снаружи.


def num_translate(key):
  eng = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten']
  rus = ['ноль', 'один', 'два', 'три', 'четыре', 'пять', 'шесть', 'семь', 'восемь', 'девять', 'десять']
  all_transl = dict(zip(eng, rus))  # создаём словарь, где ключ - вводимое англ. слово, значение - перевод
  return all_transl.get(key)  # добавляем метод .get, чтобы если перевод сделать невозможно, то вернуть None


print(num_translate('seven'))


# Задание 3

# Написать функцию thesaurus(), принимающую в качестве аргументов имена сотрудников и возвращающую словарь,
# в котором ключи — первые буквы имён, а значения — списки, содержащие имена, начинающиеся с соответствующей буквы.
# Например:
# >>> thesaurus("Иван", "Мария", "Петр", "Илья")
# {
#     "И": ["Иван", "Илья"],
#     "М": ["Мария"],
#     "П": ["Петр"]
# }
#
#
# Подумайте: полезен ли будет вам оператор распаковки?
# Как поступить, если потребуется сортировка по ключам?
# Можно ли использовать словарь в этом случае?

res = {}  # словарь, куда добавим имена. Выношу как глобальную переменную, поскольку не совсем понимаю, как в цикле
# сделать сортировку по ключу.

def thesaurus(*names):  # используем *, поскольку будет введено неизвестное количество имен
  for name in names:  # для аргументов(name) в введенных именах(names)
    key = name[0].capitalize()  # ключ = первая буква [0] в веденном имени, делаем ее также заглавной
    if key not in res:  # если ключ отсутствует в словаре
      res[key] = []  # в словаре ключу присваеваем значение (пустой список)
    res[key].append(name)  # добавляем введенное имя
  return res  # вернуть словарь


print(thesaurus('Анастасия', 'Валя', 'Борис', 'Геннадий', 'Вадим'))

# Можно ли использовать словарь в этом случае?
# Ответ: Думаю, что нужно использовать list и цикл

list_keys = list(res.keys())  # перевод в лист
list_keys.sort()

for i in list_keys:
  print(i, ':', res[i])


# Задание 5

# Реализовать функцию get_jokes(), возвращающую n шуток,
# сформированных из трех случайных слов, взятых из трёх списков (по одному из каждого):
# nouns = ["автомобиль", "лес", "огонь", "город", "дом"]
# adverbs = ["сегодня", "вчера", "завтра", "позавчера", "ночью"]
# adjectives = ["веселый", "яркий", "зеленый", "утопичный", "мягкий"]
#
# Например:
# >>> get_jokes(2)
# ["лес завтра зеленый", "город вчера веселый"]
#
#
# Документировать код функции.
# ?????? Сможете ли вы добавить еще один аргумент — флаг, разрешающий или запрещающий повторы слов в шутках
# (когда каждое слово можно использовать только в одной шутке)?
# Сможете ли вы сделать аргументы именованными?


nouns = ["автомобиль", "лес", "огонь", "город", "дом"]
adverbs = ["сегодня", "вчера", "завтра", "позавчера", "ночью"]
adjectives = ["веселый", "яркий", "зеленый", "утопичный", "мягкий"]
new = []

def get_jokes(n=1, flag=True):  # n - отвечает за то, сколько шуток выводить

  for i in range(n):  # range позволяет вывести столько шуток, сколько указали в n
    one = random.choice(nouns)  # первое рандомное слово
    two = random.choice(adverbs)  # второе рандомное слово
    three = random.choice(adjectives)  # третье рандомное слово
    new.append(f'{one}, {two}, {three}')  # добавляем в список слова в определенном виде
  return print(new)


print(get_jokes(n=2, flag=False))  # именнованные аргументы есть. Флаг возвращает None,т.к нет условий что он возвращает
# с пунктом про флаг возникли сложности
